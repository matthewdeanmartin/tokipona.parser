using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Linq;
using log4net;
using Palmmedia.ReportGenerator.Common;
using Palmmedia.ReportGenerator.Parser.Analysis;
using Palmmedia.ReportGenerator.Properties;

namespace Palmmedia.ReportGenerator.Parser
{
    /// <summary>
    /// Parser for XML reports generated by OpenCover.
    /// </summary>
    public class OpenCoverParser : ParserBase
    {
        /// <summary>
        /// The Logger.
        /// </summary>
        private static readonly ILog Logger = LogManager.GetLogger(typeof(OpenCoverParser));

        /// <summary>
        /// The module elements of the report.
        /// </summary>
        private XElement[] modules;

        /// <summary>
        /// The file elements of the report.
        /// </summary>
        private XElement[] files;

        /// <summary>
        /// The tracked methods by id.
        /// </summary>
        private IDictionary<string, string> trackedMethods;

        /// <summary>
        /// Initializes a new instance of the <see cref="OpenCoverParser"/> class.
        /// </summary>
        /// <param name="report">The report file as XContainer.</param>
        public OpenCoverParser(XContainer report)
        {
            if (report == null)
            {
                throw new ArgumentNullException("report");
            }

            this.modules = report.Descendants("Module")
                .Where(m => m.Attribute("skippedDueTo") == null)
                .ToArray();
            this.files = report.Descendants("File").ToArray();
            this.trackedMethods = report.Descendants("TrackedMethod")
                .ToDictionary(t => t.Attribute("uid").Value, t => t.Attribute("name").Value);

            var assemblyNames = this.modules
                .Select(m => m.Element("ModuleName").Value)
                .Distinct()
                .OrderBy(a => a)
                .ToArray();

            Parallel.ForEach(assemblyNames, assemblyName => this.AddAssembly(this.ProcessAssembly(assemblyName)));

            this.modules = null;
            this.files = null;
            this.trackedMethods = null;
        }

        /// <summary>
        /// Extracts the metrics from the given <see cref="XElement">XElements</see>.
        /// </summary>
        /// <param name="methods">The methods.</param>
        /// <param name="class">The class.</param>
        private static void SetMethodMetrics(IEnumerable<XElement> methods, Class @class)
        {
            foreach (var methodGroup in methods.GroupBy(m => m.Element("Name").Value))
            {
                var method = methodGroup.First();

                // Exclude properties and lambda expressions
                if (method.Attribute("skippedDueTo") != null
                    || method.HasAttributeWithValue("isGetter", "true")
                    || method.HasAttributeWithValue("isSetter", "true")
                    || Regex.IsMatch(methodGroup.Key, "::<.+>.+__"))
                {
                    continue;
                }

                var metrics = new[] 
                { 
                    new Metric(
                        "Cyclomatic Complexity", 
                        methodGroup.Max(m => int.Parse(m.Attribute("cyclomaticComplexity").Value, CultureInfo.InvariantCulture))),
                    new Metric(
                        "Sequence Coverage", 
                        methodGroup.Max(m => decimal.Parse(m.Attribute("sequenceCoverage").Value, CultureInfo.InvariantCulture))),
                    new Metric(
                        "Branch Coverage", 
                        methodGroup.Max(m => decimal.Parse(m.Attribute("branchCoverage").Value, CultureInfo.InvariantCulture)))
                };

                @class.AddMethodMetric(new MethodMetric(methodGroup.Key, metrics));
            }
        }

        /// <summary>
        /// Processes the given assembly.
        /// </summary>
        /// <param name="assemblyName">Name of the assembly.</param>
        /// <returns>The <see cref="Assembly"/>.</returns>
        private Assembly ProcessAssembly(string assemblyName)
        {
            Logger.DebugFormat("  " + Resources.CurrentAssembly, assemblyName);

            var fileIdsByFilename = this.modules
                .Where(m => m.Element("ModuleName").Value.Equals(assemblyName))
                .Elements("Files")
                .Elements("File")
                .GroupBy(f => f.Attribute("fullPath").Value, f => f.Attribute("uid").Value)
                .ToDictionary(g => g.Key, g => g.ToHashSet());

            var classNames = this.modules
                .Where(m => m.Element("ModuleName").Value.Equals(assemblyName))
                .Elements("Classes")
                .Elements("Class")
                .Where(c => !c.Element("FullName").Value.Contains("__")
                    && !c.Element("FullName").Value.Contains("<")
                    && !c.Element("FullName").Value.Contains("/")
                    && c.Attribute("skippedDueTo") == null)
                .Select(c => c.Element("FullName").Value)
                .Distinct()
                .OrderBy(name => name)
                .ToArray();

            var assembly = new Assembly(assemblyName);

            Parallel.ForEach(classNames, className => assembly.AddClass(this.ProcessClass(fileIdsByFilename, assembly, className)));

            return assembly;
        }

        /// <summary>
        /// Processes the given class.
        /// </summary>
        /// <param name="fileIdsByFilename">Dictionary containing the file ids by filename.</param>
        /// <param name="assembly">The assembly.</param>
        /// <param name="className">Name of the class.</param>
        /// <returns>The <see cref="Class"/>.</returns>
        private Class ProcessClass(Dictionary<string, HashSet<string>> fileIdsByFilename, Assembly assembly, string className)
        {
            var fileIdsOfClass = this.modules
                .Where(m => m.Element("ModuleName").Value.Equals(assembly.Name))
                .Elements("Classes")
                .Elements("Class")
                .Where(c => c.Element("FullName").Value.Equals(className) || c.Element("FullName").Value.StartsWith(className + "/<", StringComparison.Ordinal))
                .Elements("Methods")
                .Elements("Method")
                .Where(m => m.Element("FileRef") != null)
                .Select(m => m.Element("FileRef").Attribute("uid").Value)
                .Distinct()
                .ToHashSet();

            var filesOfClass = this.files
                .Where(file => fileIdsOfClass.Contains(file.Attribute("uid").Value))
                .Select(file => file.Attribute("fullPath").Value)
                .Distinct()
                .ToArray();

            var @class = new Class(className, assembly);

            foreach (var file in filesOfClass)
            {
                @class.AddFile(this.ProcessFile(fileIdsByFilename[file], @class, file));
            }

            @class.CoverageQuota = this.GetCoverageQuotaOfClass(assembly, className);

            return @class;
        }

        /// <summary>
        /// Processes the file.
        /// </summary>
        /// <param name="fileIds">The file ids of the class.</param>
        /// <param name="class">The class.</param>
        /// <param name="filePath">The file path.</param>
        /// <returns>The <see cref="CodeFile"/>.</returns>
        private CodeFile ProcessFile(HashSet<string> fileIds, Class @class, string filePath)
        {
            var methods = this.modules
                .Where(m => m.Element("ModuleName").Value.Equals(@class.Assembly.Name))
                .Elements("Classes")
                .Elements("Class")
                .Where(c => c.Element("FullName").Value.StartsWith(@class.Name, StringComparison.Ordinal))
                .Elements("Methods")
                .Elements("Method")
                .Where(m => m.Element("FileRef") != null && fileIds.Contains(m.Element("FileRef").Attribute("uid").Value))
                .ToArray();

            SetMethodMetrics(methods, @class);

            var seqpntsOfFile = methods
                .Elements("SequencePoints")
                .Elements("SequencePoint")
                .Select(seqpnt => new
                {
                    LineNumber = int.Parse(seqpnt.Attribute("sl").Value, CultureInfo.InvariantCulture),
                    Visits = int.Parse(seqpnt.Attribute("vc").Value, CultureInfo.InvariantCulture),
                    TrackedMethodRefs = seqpnt.Elements("TrackedMethodRefs")
                        .Elements("TrackedMethodRef")
                        .Select(t => new
                        {
                            Visits = int.Parse(t.Attribute("vc").Value, CultureInfo.InvariantCulture),
                            TrackedMethodId = t.Attribute("uid").Value
                        })
                })
                .OrderBy(seqpnt => seqpnt.LineNumber)
                .ToArray();

            int[] coverage = new int[] { };

            var trackedMethodsCoverage = seqpntsOfFile
                .SelectMany(s => s.TrackedMethodRefs)
                .Select(t => t.TrackedMethodId)
                .Distinct()
                .ToDictionary(id => id, id => new int[] { });

            if (seqpntsOfFile.Length > 0)
            {
                coverage = new int[seqpntsOfFile[seqpntsOfFile.LongLength - 1].LineNumber + 1];

                for (int i = 0; i < coverage.Length; i++)
                {
                    coverage[i] = -1;
                }

                foreach (var name in trackedMethodsCoverage.Keys.ToArray())
                {
                    trackedMethodsCoverage[name] = (int[])coverage.Clone();
                }

                foreach (var seqpnt in seqpntsOfFile)
                {
                    int visits = coverage[seqpnt.LineNumber] == -1 ? seqpnt.Visits : coverage[seqpnt.LineNumber] + seqpnt.Visits;
                    coverage[seqpnt.LineNumber] = visits;

                    if (visits > -1)
                    {
                        foreach (var trackedMethodCoverage in trackedMethodsCoverage)
                        {
                            if (trackedMethodCoverage.Value[seqpnt.LineNumber] == -1)
                            {
                                trackedMethodCoverage.Value[seqpnt.LineNumber] = 0;
                            }
                        }
                    }

                    foreach (var trackedMethod in seqpnt.TrackedMethodRefs)
                    {
                        var trackedMethodCoverage = trackedMethodsCoverage[trackedMethod.TrackedMethodId];
                        trackedMethodCoverage[seqpnt.LineNumber] = trackedMethodCoverage[seqpnt.LineNumber] == -1 ? trackedMethod.Visits : trackedMethodCoverage[seqpnt.LineNumber] + trackedMethod.Visits;
                    }
                }
            }

            var codeFile = new CodeFile(filePath, coverage);

            foreach (var trackedMethodCoverage in trackedMethodsCoverage)
            {
                string name = null;

                // Sometimes no corresponding MethodRef element exists
                if (this.trackedMethods.TryGetValue(trackedMethodCoverage.Key, out name))
                {
                    string shortName = name.Substring(name.Substring(0, name.IndexOf(':') + 1).LastIndexOf('.') + 1);
                    TestMethod testMethod = new TestMethod(name, shortName);
                    codeFile.AddCoverageByTestMethod(testMethod, trackedMethodCoverage.Value);
                }
            }

            return codeFile;
        }

        /// <summary>
        /// Gets the coverage quota of a class.
        /// This method is used to get coverage quota if line coverage is not available.
        /// </summary>
        /// <param name="assembly">The assembly.</param>
        /// <param name="className">Name of the class.</param>
        /// <returns>The coverage quota.</returns>
        private decimal? GetCoverageQuotaOfClass(Assembly assembly, string className)
        {
            var methodGroups = this.modules
                .Where(m => m.Element("ModuleName").Value.Equals(assembly.Name))
                .Elements("Classes")
                .Elements("Class")
                .Where(c => c.Element("FullName").Value.StartsWith(className, StringComparison.Ordinal))
                .Elements("Methods")
                .Elements("Method")
                .Where(m => m.Attribute("skippedDueTo") == null && m.Element("FileRef") == null && !m.Element("Name").Value.EndsWith(".ctor()", StringComparison.OrdinalIgnoreCase))
                .GroupBy(m => m.Element("Name").Value)
                .ToArray();

            int visitedMethods = methodGroups.Count(g => g.Any(m => m.Attribute("visited").Value == "true"));

            return (methodGroups.Length == 0) ? (decimal?)null : (decimal)Math.Truncate(1000 * (double)visitedMethods / (double)methodGroups.Length) / 10;
        }
    }
}
